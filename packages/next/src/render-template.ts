/**
 * Template rendering helper for Next.js API routes
 *
 * This module provides renderTemplate() which handles client component templates
 * (like those using Recharts) that can't be imported directly due to RSC restrictions.
 *
 * Templates are pre-bundled at build time by withPdfn(), eliminating the need
 * for runtime esbuild and serverExternalPackages configuration.
 *
 * Usage:
 *   import { renderTemplate } from '@pdfn/next';
 *
 *   // In API route
 *   const html = await renderTemplate('report', { data: myData });
 */

import { existsSync, readFileSync } from "node:fs";
import { join, resolve, isAbsolute } from "node:path";
import {
  getPageDimensions,
  generateClientHtml,
  type PageOrientation,
} from "@pdfn/core";
import { getPrecompiledBundleAsync } from "./bundle-loader.js";

/**
 * Options for rendering a template
 */
export interface RenderTemplateOptions {
  /**
   * Props to pass to the template component
   */
  props?: Record<string, unknown>;

  /**
   * Document title for the HTML
   */
  title?: string;

  /**
   * Directory where templates are located
   * @default './pdfn-templates'
   */
  templatesDir?: string;

  /**
   * Base directory for resolving paths (defaults to process.cwd())
   */
  cwd?: string;

  /**
   * Page size for the PDF (A4, Letter, Legal, etc.)
   * @default 'A4'
   */
  pageSize?: string;

  /**
   * Page orientation
   * @default 'portrait'
   */
  orientation?: PageOrientation;

  /**
   * Page margin (CSS value like '1in', '0.75in', etc.)
   * @default '0.75in'
   */
  margin?: string;
}

/**
 * Result of rendering a template
 */
export interface RenderTemplateResult {
  /** The generated HTML string */
  html: string;
}

// Cached CSS from static import (set by transform-loader injected code)
let cachedCss: string | null = null;

/**
 * Set the pre-compiled CSS (called by transform-loader injected code).
 * This allows static imports to be traced by webpack/turbopack for serverless.
 */
export function __setPrecompiledCss(css: string): void {
  cachedCss = css;
}

/**
 * Try to load pre-compiled Tailwind CSS from node_modules/.pdfn/tailwind.js
 * This CSS is generated by withPdfn() at build time.
 */
function loadPrecompiledCss(cwd: string): string {
  // First try cached CSS (set via __setPrecompiledCss from static import)
  if (cachedCss !== null) {
    return cachedCss;
  }

  const cssModulePath = join(cwd, "node_modules", ".pdfn", "tailwind.js");

  if (existsSync(cssModulePath)) {
    try {
      // Read the module content and extract the CSS string
      const moduleContent = readFileSync(cssModulePath, "utf8");

      // The module exports: export const css = "...";
      // Extract the CSS string using regex
      const match = moduleContent.match(/export const css = (["'`])(.*)(\1)/s);
      if (match && match[2]) {
        // Parse the JSON-encoded string
        return JSON.parse(`"${match[2].replace(/\\"/g, '"').replace(/"/g, '\\"')}"`);
      }

      // Alternative: try to extract from JSON.stringify format
      const jsonMatch = moduleContent.match(/export const css = (".*")/s);
      if (jsonMatch && jsonMatch[1]) {
        return JSON.parse(jsonMatch[1]);
      }

      console.warn("[pdfn/next] Could not parse pre-compiled CSS module");
      return "";
    } catch (e) {
      console.warn("[pdfn/next] Failed to load pre-compiled CSS:", e);
      return "";
    }
  }

  console.warn(
    "[pdfn/next] No pre-compiled CSS found. Ensure withPdfn() is configured in next.config.ts"
  );
  return "";
}

/**
 * Resolve template path from template ID or path
 */
function resolveTemplatePath(
  templateIdOrPath: string,
  templatesDir: string,
  cwd: string
): string {
  // If already an absolute path, use it directly
  if (isAbsolute(templateIdOrPath)) {
    return templateIdOrPath;
  }

  // If it looks like a relative path (starts with ./ or ../)
  if (templateIdOrPath.startsWith("./") || templateIdOrPath.startsWith("../")) {
    return resolve(cwd, templateIdOrPath);
  }

  // Otherwise, treat as template ID and look in templates directory
  const withExtension = templateIdOrPath.endsWith(".tsx")
    ? templateIdOrPath
    : `${templateIdOrPath}.tsx`;

  return resolve(cwd, templatesDir, withExtension);
}

/**
 * Render a template to HTML for PDF generation.
 *
 * This function handles client component templates (like those using Recharts)
 * that cannot be directly imported in Next.js API routes due to RSC restrictions.
 *
 * Templates are pre-bundled at build time by withPdfn(), so no runtime
 * bundling or esbuild dependency is required.
 *
 * @param templateIdOrPath - Template ID (e.g., 'report') or path
 * @param options - Render options
 * @returns Promise resolving to render result with HTML string
 *
 * @example
 * ```ts
 * // In Next.js API route (app/api/pdf/route.ts)
 * import { renderTemplate } from '@pdfn/next';
 *
 * export async function GET(request: NextRequest) {
 *   const { html } = await renderTemplate('report', {
 *     props: { data: salesData },
 *     title: 'Sales Report'
 *   });
 *
 *   // Send HTML to pdfn server for PDF generation
 *   const response = await fetch('http://localhost:3456/generate', {
 *     method: 'POST',
 *     headers: { 'Content-Type': 'application/json' },
 *     body: JSON.stringify({ html })
 *   });
 *
 *   return new Response(await response.arrayBuffer(), {
 *     headers: { 'Content-Type': 'application/pdf' }
 *   });
 * }
 * ```
 */
export async function renderTemplate(
  templateIdOrPath: string,
  options: RenderTemplateOptions = {}
): Promise<RenderTemplateResult> {
  const {
    props = {},
    title,
    templatesDir = "./pdfn-templates",
    cwd = process.cwd(),
    pageSize = "A4",
    orientation = "portrait",
    margin = "0.75in",
  } = options;

  // Normalize template ID (remove path components and extension)
  const templateId = templateIdOrPath
    .replace(/^\.\//, "")
    .replace(/^pdfn-templates\//, "")
    .replace(/\.(tsx?|jsx?)$/, "");

  console.log(`[pdfn/next] Rendering template: ${templateId}`);

  // Try to load pre-compiled bundle (created by withPdfn at build time)
  const bundleCode = await getPrecompiledBundleAsync(templateId, cwd);

  if (!bundleCode) {
    // No pre-compiled bundle found
    // This means withPdfn() wasn't configured or the template doesn't have "use client"
    const templatePath = resolveTemplatePath(templateIdOrPath, templatesDir, cwd);

    if (!existsSync(templatePath)) {
      throw new Error(
        `[pdfn/next] Template not found: ${templatePath}\n\n` +
          `Make sure the template file exists in your pdfn-templates directory.`
      );
    }

    throw new Error(
      `[pdfn/next] No pre-compiled bundle found for template "${templateId}".\n\n` +
        `Ensure withPdfn() is configured in next.config.ts and the template has "use client" directive.\n` +
        `Run 'next build' or restart 'next dev' to bundle templates.`
    );
  }

  // Load pre-compiled Tailwind CSS
  const tailwindCss = loadPrecompiledCss(cwd);

  // Infer title from template ID if not provided
  const resolvedTitle =
    title ||
    templateId
      .split("/")
      .pop()
      ?.replace(/[-_]/g, " ")
      .replace(/\b\w/g, (c) => c.toUpperCase()) ||
    "Document";

  // Get page dimensions based on size and orientation
  const { width, height } = getPageDimensions(pageSize, orientation);

  // Generate HTML with the pre-compiled bundle, props, CSS, and page config
  const html = generateClientHtml({
    bundleCode,
    props,
    title: resolvedTitle,
    css: tailwindCss,
    pageConfig: {
      width: `${width}pt`,
      height: `${height}pt`,
      margin,
    },
  });

  console.log(`[pdfn/next] Template rendered: ${resolvedTitle}`);

  return { html };
}

/**
 * Check if a template requires client-side rendering.
 *
 * This reads the template file and checks for "use client" directive.
 * Use this to decide whether to use renderTemplate() or standard render().
 *
 * @param templateIdOrPath - Template ID (e.g., 'report') or path
 * @param options - Options for resolving the template path
 * @returns true if the template has "use client" directive
 *
 * @example
 * ```ts
 * if (requiresClientRendering('report')) {
 *   // Use renderTemplate for client components
 *   const { html } = await renderTemplate('report', { props });
 * } else {
 *   // Use standard render for server components
 *   const html = await render(<Invoice {...props} />);
 * }
 * ```
 */
export function requiresClientRendering(
  templateIdOrPath: string,
  options: { templatesDir?: string; cwd?: string } = {}
): boolean {
  const { templatesDir = "./pdfn-templates", cwd = process.cwd() } = options;

  const templatePath = resolveTemplatePath(templateIdOrPath, templatesDir, cwd);

  if (!existsSync(templatePath)) {
    return false;
  }

  try {
    const content = readFileSync(templatePath, "utf8");
    // Check for "use client" directive at the start of the file
    return /^["']use client["']/m.test(content.trim());
  } catch {
    return false;
  }
}
