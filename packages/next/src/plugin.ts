/**
 * CSS compilation and template bundling for pdfn templates
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { resolve, dirname, join, basename } from "node:path";
import { hasUseClientDirective, hasDefaultExport } from "@pdfn/core";
import { compileTailwind } from "@pdfn/core/tailwind";
import fg from "fast-glob";

export interface PdfnPluginOptions {
  /**
   * Enable debug logging for CSS compilation.
   * @default false
   */
  debug?: boolean;
}

/**
 * Module path for pre-compiled Tailwind CSS
 */
export const CSS_MODULE_PATH = ".pdfn/tailwind.js";

/**
 * Compile Tailwind CSS for templates in pdfn-templates/ and write to output file
 */
export async function compileTailwindCss(
  cwd: string,
  debug = false
): Promise<void> {
  const { css } = await compileTailwind({
    templatePatterns: ["./pdfn-templates/**/*.tsx"],
    cwd,
    debug,
    logPrefix: "[pdfn:next]",
  });

  // Write CSS to module file
  writeCssModule(cwd, css);
}

/**
 * Write CSS module to node_modules/.pdfn/
 */
function writeCssModule(cwd: string, css: string): void {
  const pdfnDir = join(cwd, "node_modules", ".pdfn");
  const cssFilePath = join(pdfnDir, "tailwind.js");

  if (!existsSync(pdfnDir)) {
    mkdirSync(pdfnDir, { recursive: true });
  }

  const moduleContent = `// Auto-generated by @pdfn/next - DO NOT EDIT
export const css = ${JSON.stringify(css)};
export default css;
`;
  writeFileSync(cssFilePath, moduleContent);
}

/**
 * Write empty CSS module
 */
function writeEmptyCssModule(cwd: string): void {
  writeCssModule(cwd, "");
}

// Import types and constants from bundle-loader (runtime code)
import {
  BUNDLES_DIR,
  BUNDLES_MANIFEST,
  type BundleManifestEntry,
  type BundleManifest,
} from "./bundle-loader.js";

// Re-export for backwards compatibility
export { BUNDLES_DIR, BUNDLES_MANIFEST, type BundleManifestEntry, type BundleManifest };

/**
 * Get template ID from file path
 */
function getTemplateId(filePath: string, templatesDir: string): string {
  // Get relative path from templates directory
  const relativePath = filePath.replace(templatesDir + "/", "");
  // Remove extension and convert to ID
  return relativePath.replace(/\.(tsx?|jsx?)$/, "").replace(/\//g, "-");
}

/**
 * Generate entry point code for a template bundle.
 * Props are read from window.__PDFN_PROPS__ at runtime.
 */
function generateBundleEntryPoint(templateSource: string): string {
  return `
import React from "react";
import { createRoot } from "react-dom/client";
import Template from ${JSON.stringify(templateSource)};

// Props passed from server via window.__PDFN_PROPS__
const PROPS = window.__PDFN_PROPS__ || {};

// Initialize PDFN ready state
window.PDFN = window.PDFN || {
  ready: false,
  reactReady: false
};

// Wait for DOM to be ready
function init() {
  const container = document.getElementById("pdfn-root");
  if (!container) {
    console.error("[pdfn] Could not find #pdfn-root container");
    return;
  }

  const root = createRoot(container);
  root.render(React.createElement(Template, PROPS));

  // Signal React render complete after a frame
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      if (window.PDFN && window.PDFN.signalReactReady) {
        window.PDFN.signalReactReady();
      } else {
        window.PDFN = window.PDFN || {};
        window.PDFN.reactReady = true;
        console.log("[pdfn] React render complete");
      }
    });
  });
}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init);
} else {
  init();
}
`;
}

/**
 * esbuild plugin to handle server-only packages when bundling for browser.
 */
function serverOnlyPlugin(esbuild: typeof import("esbuild")): import("esbuild").Plugin {
  // Packages that should be shimmed out when bundling for browser
  // Note: @pdfn/core main entry is browser-safe, only @pdfn/core/tailwind is server-only
  const serverPackages = ["@pdfn/client", "@pdfn/core/tailwind", "fast-glob"];
  const nodeBuiltins = [
    "fs", "path", "module", "crypto", "os", "child_process", "tty",
    "stream", "util", "events", "buffer", "assert", "string_decoder",
    "node:fs", "node:path", "node:module", "node:crypto", "node:os", "node:child_process",
    "node:stream", "node:util", "node:events", "node:buffer", "node:assert", "node:string_decoder",
    "node:tty",
  ];

  return {
    name: "pdfn-server-only",
    setup(build) {
      build.onResolve({ filter: new RegExp(`^(${serverPackages.join("|")})`) }, (args) => ({
        path: args.path,
        namespace: "server-only-shim",
      }));

      build.onResolve({ filter: new RegExp(`^(${nodeBuiltins.join("|")})$`) }, (args) => ({
        path: args.path,
        namespace: "node-builtin-shim",
      }));

      build.onLoad({ filter: /.*/, namespace: "server-only-shim" }, () => ({
        contents: "export default {}; export const __pdfn_server_only = true;",
        loader: "js",
      }));

      build.onLoad({ filter: /.*/, namespace: "node-builtin-shim" }, () => ({
        contents: "export default {}; export const readFileSync = () => { throw new Error('fs not available in browser'); };",
        loader: "js",
      }));
    },
  };
}

/**
 * Bundle a single template file for client-side rendering.
 * Returns the bundle code for inlining in the manifest.
 */
async function bundleTemplate(
  templatePath: string,
  outputPath: string,
  cwd: string,
  log: (...args: unknown[]) => void
): Promise<string> {
  const esbuild = await import("esbuild");

  const entryContent = generateBundleEntryPoint(templatePath);
  const resolveDir = dirname(templatePath);

  const result = await esbuild.build({
    stdin: {
      contents: entryContent,
      resolveDir,
      loader: "tsx",
    },
    bundle: true,
    format: "iife",
    platform: "browser",
    target: ["es2020"],
    minify: process.env.NODE_ENV === "production",
    sourcemap: false,
    write: false,
    jsx: "automatic",
    jsxImportSource: "react",
    plugins: [serverOnlyPlugin(esbuild)],
    define: {
      "process.env.NODE_ENV": '"production"',
      "process.env.DEBUG": '""',
      "process.env": "{}",
    },
    nodePaths: [resolve(cwd, "node_modules")],
  });

  const outputFile = result.outputFiles?.[0];
  if (!outputFile) {
    throw new Error(`esbuild produced no output for ${templatePath}`);
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Write to file (for local development)
  writeFileSync(outputPath, outputFile.text);
  log(`Bundled: ${basename(templatePath)} â†’ ${basename(outputPath)} (${(outputFile.text.length / 1024).toFixed(1)}KB)`);

  // Return bundle code for inlining in manifest
  return outputFile.text;
}

/**
 * Bundle all client templates at build time.
 *
 * Scans for templates with "use client" directive in pdfn-templates/
 * and pre-bundles them so no runtime bundling (esbuild) is needed.
 */
export async function bundleClientTemplates(
  cwd: string,
  debug = false
): Promise<BundleManifest> {
  const templatePatterns = ["./pdfn-templates/**/*.tsx"];
  const log = (...args: unknown[]) => {
    if (debug) console.log("[pdfn:next]", ...args);
  };

  // Find all template files
  const files = await fg(templatePatterns, {
    cwd,
    absolute: true,
    ignore: ["**/node_modules/**"],
  });

  const bundlesDir = join(cwd, "node_modules", BUNDLES_DIR);
  const manifestPath = join(cwd, "node_modules", BUNDLES_MANIFEST);

  // Ensure bundles directory exists
  if (!existsSync(bundlesDir)) {
    mkdirSync(bundlesDir, { recursive: true });
  }

  const manifest: BundleManifest = {
    version: "1.0",
    templates: {},
  };

  // Get templates directory for ID generation
  const templatesDir = resolve(cwd, "pdfn-templates");

  // Find and bundle client templates
  let clientTemplateCount = 0;
  for (const file of files) {
    const content = readFileSync(file, "utf8");

    // Skip non-client templates (no "use client" directive)
    if (!hasUseClientDirective(content)) {
      continue;
    }

    // Skip component files without default export (not templates)
    if (!hasDefaultExport(content)) {
      log(`Skipping ${basename(file)} - has "use client" but no default export (component file)`);
      continue;
    }

    clientTemplateCount++;
    const templateId = getTemplateId(file, templatesDir);
    const bundlePath = join(bundlesDir, `${templateId}.js`);

    try {
      const bundleCode = await bundleTemplate(file, bundlePath, cwd, log);

      manifest.templates[templateId] = {
        id: templateId,
        sourcePath: file,
        bundlePath,
        bundledAt: new Date().toISOString(),
        // Inline bundle code for serverless deployment
        code: bundleCode,
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      console.error(`[pdfn:next] Failed to bundle ${templateId}: ${message}`);
    }
  }

  // Write manifest as JSON
  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));

  // Also write as a JavaScript module for serverless environments
  // This allows it to be traced and bundled by Next.js
  const bundlesModulePath = join(cwd, "node_modules", ".pdfn", "bundles.js");
  const bundlesModuleContent = `// Auto-generated by @pdfn/next - DO NOT EDIT
export const manifest = ${JSON.stringify(manifest, null, 2)};
export default manifest;
`;
  writeFileSync(bundlesModulePath, bundlesModuleContent);

  if (clientTemplateCount > 0) {
    log(`Bundled ${clientTemplateCount} client template(s)`);
  } else {
    log("No client templates found (no 'use client' directives)");
  }

  return manifest;
}

// Re-export runtime functions from bundle-loader for backwards compatibility
export { loadBundleManifest, getPrecompiledBundle, getPrecompiledBundleAsync } from "./bundle-loader.js";
